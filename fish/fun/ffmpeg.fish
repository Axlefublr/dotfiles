#!/usr/bin/env fish

function ffmpeg-video-convert
    echo 'convert video to (maybe) another format, not reencoding the audio. optionally, you can cut out only some portion of the video' >&2
    read -P 'input: ' -l input || return 121
    not test -f "$input" && return 121
    set -l input_basename (path basename $input | path change-extension '')
    set -l extension (path extension $input)

    echo 'if extension is not specified, extension of input is assumed' >&2
    echo 'if comletely blank, title is autogenerated as well' >&2
    echo '!! in name is replaced with basename of input file'
    read -P 'output: ' -f output || return 121
    if not test "$output"
        set -f output (uclanr 3 -j -)$extension
    else if test -z "$(string extension $output)"
        set output output$extension
    end
    set output (string replace -a '!!' $input_basename $output)

    echo 'format is [hh:mm:]ss[.ms]' >&2
    echo 'skip if you want to assume "start of video"' >&2
    read -P 'from: ' -l from || return 121
    if test "$from"
        set from -ss $from
        echo 'skip if you want to assume "end of video"' >&2
    else
        echo 'skip to not cut at all' >&2
    end
    read -P 'to: ' -l to || return 121
    if test "$to"
        set to -to $to
    end

    ffmpeg -i $input $from $to -c:a copy $output
    set_color -o a9b665
    echo "ffmpeg -i $input $from $to -c:a copy $output"
end
funcsave ffmpeg-cut-from-and-to >/dev/null

function ffmpeg-compress-video
    echo 'compress video, maybe changing its extension' >&2
    read -P 'input: ' -l input || return 121
    not test -f "$input" && return 121
    set -l input_basename (path basename $input | path change-extension '')
    set -l extension (path extension $input)

    echo 'if extension is not specified, extension of input is assumed' >&2
    echo 'if comletely blank, title is autogenerated as well' >&2
    echo '!! in name is replaced with basename of input file'
    read -P 'output: ' -f output || return 121
    if not test "$output"
        set -f output (uclanr 3 -j -)$extension
    else if test -z "$(string extension $output)"
        set output output$extension
    end
    set output (string replace -a '!!' $input_basename $output)

    ffmpeg -i $input -c:v libx264 -crf 28 -preset veryslow -c:a aac -b:a 64k -movflags +faststart $output
    set_color -o a9b665
    echo "ffmpeg -i $input -c:v libx264 -crf 28 -preset veryslow -c:a aac -b:a 64k -movflags +faststart $output"
end
funcsave ffmpeg-compress-video >/dev/null

function ffcombine --description='INPUT1 INPUT2 OUTPUT'
    ffmpeg -i $argv[1] -c copy -bsf:v h264_mp4toannexb -f mpegts input1.ts
    ffmpeg -i $argv[2] -c copy -bsf:v h264_mp4toannexb -f mpegts input2.ts
    echo "file 'input1.ts'
    file 'input2.ts'" >inputs.txt
    ffmpeg -f concat -safe 0 -i inputs.txt -c copy $argv[3]
    rm inputs.txt input1.ts input2.ts
    bell
end
funcsave ffcombine >/dev/null

function ffto-mp3
    ffmpeg -i $argv[1] -map_metadata -1 -vn -acodec libmp3lame (path change-extension mp3 $argv[1])
end
funcsave ffto-mp3 >/dev/null

function mp43 --description='All mp4 here into mp3'
    for file in (ls)
        ffto-mp3 $file
        trash-put $file
    end
    bell
end
funcsave mp43 >/dev/null

function rename-all-random
    for file in (ls)
        mv $file (uclanr -j - 3)(path extension $file)
    end
end
funcsave rename-all-random >/dev/null

function remove-metadata
    ffmpeg -i $argv[1] -c:a copy -c:v copy -map_metadata -1 _$argv[1]
    mv -f _$argv[1] $argv[1]
end
funcsave remove-metadata >/dev/null
