#!/usr/bin/env fish

function ffmpeg_cut_video
    echo 'reencode video with x264, audio with aac.'\n'optionally, cut out some portion of the video.' >&2
    for input in $argv
        if not test -f "$input"
            echo "not a real file, skipping ($input)" >&2
            continue
        end
        echo "processing $input" >&2
        set -l input_basename (path_clear_suffix += (path basename -E $input))
        set -l output "$input_basename"!

        if test -z "$(ffprobe -v error -select_streams a -show_entries stream=index -of csv=p=0 $input)"
            echo 'no audio stream. faking it.' >&2
            set -f $fake_audio -f lavfi -i anullsrc=channel_layout=stereo:sample_rate=44100 -shortest
        end

        confirm.rs 'cut from?' '[j]es' '[k]o' | read -l response
        if test "$response" = j
            set -l from (cat /tmp/mine/mpv-loop-a)
            set output "$output$(math -s 0 -m round $from)"
            set -f from -ss "$from"s
        else
            set -e from
        end
        confirm.rs 'cut to?' '[j]es' '[k]o' | read -l response
        if test "$response" = j
            set -l to (cat /tmp/mine/mpv-loop-b)
            set output "$output-$(math -s 0 -m round $to)"
            set -f to -to "$to"s
        else
            set -e to
        end
        set output "$output.mp4"

        pueue add -g cpu -- ffmpeg -y -i "$input" $from $to \
            $fake_audio \
            -c:v libx264 \
            -preset medium \
            -crf 18 \
            -map_metadata -1 \
            -movflags +faststart \
            -c:a aac \
            -b:a 128K \
            -shortest \
            "$output"
    end
end
funcsave ffmpeg_cut_video >/dev/null

function ffmpeg_convert_to_mp3
    for file in $argv
        not test -f "$file" && continue
        set -l output (path change-extension '' $file)!

        confirm.rs 'cut from?' '[j]es' '[k]o' | read -l response
        if test "$response" = j
            set -l from (cat /tmp/mine/mpv-loop-a)
            set output "$output$(math -s 0 -m round $from)"
            set -f from -ss "$from"s
        else
            set -e from
        end
        confirm.rs 'cut to?' '[j]es' '[k]o' | read -l response
        if test "$response" = j
            set -l to (cat /tmp/mine/mpv-loop-b)
            set output "$output-$(math -s 0 -m round $to)"
            set -f to -to "$to"s
        else
            set -e to
        end
        set output "$output.mp3"

        pueue add -g cpu -- ffmpeg -y -i "$file" \
            $from $to \
            -c:a libmp3lame -q:a 2 \
            -vn \
            -map_metadata -1 \
            $output
    end
end
funcsave ffmpeg_convert_to_mp3 >/dev/null

function ffmpeg_combine_two_videos_into_one
    # TODO: take arbitrary amount of input files
    echo 'combine two videos into one' >&2
    read -P 'input: ' -l input || return 121
    not test -f "$input" && return 121
    set -l input_basename (path basename $input | path change-extension '')
    set -l extension (path extension $input)

    read -P 'input 2: ' -l input2 || return 121
    not test -f "$input2" && return 121

    echo 'if extension is not specified, extension of *first* input is assumed' >&2
    echo 'if comletely blank, title is autogenerated as well' >&2
    echo '!! in name is replaced with basename of *first* input file'
    read -P 'output: ' -f output || return 121
    if not test "$output"
        set -f output (uclanr 3 -j -)$extension
    else if test -z "$(string extension $output)"
        set output $output$extension
    end
    set output (string replace -a '!!' $input_basename $output)

    ffmpeg -i "$input" -c copy -bsf:v h264_mp4toannexb -f mpegts input1.ts
    ffmpeg -i "$input2" -c copy -bsf:v h264_mp4toannexb -f mpegts input2.ts
    echo "file 'input1.ts'
    file 'input2.ts'" >inputs.txt
    ffmpeg -f concat -safe 0 -i inputs.txt -c copy "$output"
    rm inputs.txt input1.ts input2.ts
end
funcsave ffmpeg_combine_two_videos_into_one >/dev/null
