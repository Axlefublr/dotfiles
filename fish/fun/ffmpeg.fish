#!/usr/bin/env fish

function ffmpeg_convert_video
    echo 'convert video to maybe another format, maybe not reencoding the audio, maybe removing it.'\n'optionally, you can cut out only some portion of the video' >&2
    set -l files $argv
    not test "$files" && return 121
    for input in $files
        if not test -f "$input"
            echo "not a real file, skipping ($input)" >&2
            continue
        end
        echo "processing $input" >&2
        set -l input_basename (path basename $input | path change-extension '')
        set -l extension (path extension $input)

        echo 'if extension is not specified, extension of input is assumed' >&2
        echo '% — input basename (no ext)' >&2
        echo '! — input extension (with .)' >&2
        read -P 'output: ' -f output || return 121
        if not test "$output"
            echo 'please enter output filepath' >&2
            return 1
        end
        set output (string replace '%' $input_basename $output)
        set output (string replace '!' $extension $output)

        if test -z "$(path extension $output)"
            set output $output$extension
        end

        echo '[hh:mm:]ss[.ms]' >&2
        echo 'skip to assume “start of video”' >&2
        read -P 'from: ' -l from || return 121
        if test "$from"
            set from -ss $from
            echo 'skip if you want to assume "end of video"' >&2
        else
            echo 'skip to not cut at all' >&2
            set -e from
        end
        read -P 'to: ' -l to || return 121
        if test "$to"
            set to -to $to
        else
            set -e to
        end
        confirm.rs 'copy over audio channel?' '[j]es' '[k]o' '[m]ute audio instead' | read -l response
        if test "$response" = j
            set -f copy_audio -c:a copy
        else if test "$response" = m
            set -f copy_audio -an
        else if test "$response" = k
            set -e copy_audio
        else
            return
        end
        confirm.rs 'copy over video channel?'\n'(fails if you\'re doing something with the video)' '[j]es' '[k]o' | read -l response
        if test "$response" = j
            set copy_video -c:v copy
        else if test "$response" = k
            set -e copy_video
        else
            return
        end

        pueue add -g cpu -- ffmpeg -i "$input" $from $to $copy_audio $copy_video "$output"
    end
end
funcsave ffmpeg_convert_video >/dev/null

function ffmpeg_compress_video
    echo 'compress video, maybe changing its extension' >&2
    set -l files $argv
    not test "$files" && return 121
    for input in $files
        if not test -f "$input"
            echo "not a real file, skipping ($input)" >&2
            continue
        end

        echo "processing $input" >&2
        set -l input_basename (path basename $input | path change-extension '')
        set -l extension (path extension $input)

        echo 'if extension is not specified, extension of input is assumed' >&2
        echo 'if comletely blank, title is autogenerated as well' >&2
        echo '!! in name is replaced with basename of input file'
        read -P 'output: ' -f output || return 121
        if not test "$output"
            set -f output (uclanr 3 -j -)$extension
        else if test -z "$(path extension $output)"
            set output $output$extension
        end
        set output (string replace -a '!!' $input_basename $output)

        pueue add -g cpu -- ffmpeg_compress "$input" "$output" -crf 28 -preset veryslow -b:a 64k
    end
end
funcsave ffmpeg_compress_video >/dev/null

function ffmpeg_compress
    ffmpeg -y -i "$argv[1]" -c:v libx264 -c:a aac -movflags +faststart $argv[3..] "$argv[2]"
end
funcsave ffmpeg_compress >/dev/null

function ffmpeg_combine_two_videos_into_one
    # TODO: take arbitrary amount of input files
    echo 'combine two videos into one' >&2
    read -P 'input: ' -l input || return 121
    not test -f "$input" && return 121
    set -l input_basename (path basename $input | path change-extension '')
    set -l extension (path extension $input)

    read -P 'input 2: ' -l input2 || return 121
    not test -f "$input2" && return 121

    echo 'if extension is not specified, extension of *first* input is assumed' >&2
    echo 'if comletely blank, title is autogenerated as well' >&2
    echo '!! in name is replaced with basename of *first* input file'
    read -P 'output: ' -f output || return 121
    if not test "$output"
        set -f output (uclanr 3 -j -)$extension
    else if test -z "$(string extension $output)"
        set output $output$extension
    end
    set output (string replace -a '!!' $input_basename $output)

    ffmpeg -i "$input" -c copy -bsf:v h264_mp4toannexb -f mpegts input1.ts
    ffmpeg -i "$input2" -c copy -bsf:v h264_mp4toannexb -f mpegts input2.ts
    echo "file 'input1.ts'
    file 'input2.ts'" >inputs.txt
    ffmpeg -f concat -safe 0 -i inputs.txt -c copy "$output"
    rm inputs.txt input1.ts input2.ts
end
funcsave ffmpeg_combine_two_videos_into_one >/dev/null

function ffmpeg_convert_to_mp3
    echo 'metadata is removed' >&2
    for file in $argv
        not test -f "$file" && continue
        echo "processing $file" >&2
        confirm.rs 'delete input file?' '[j]es' '[k]o' | read -l response
        pueue add -g cpu -- ffmpeg -i "$file" -map_metadata -1 -vn -acodec libmp3lame (path change-extension mp3 "$file")
        test "$response" = j && pueue add -g cpu -- gomi $file
    end
end
funcsave ffmpeg_convert_to_mp3 >/dev/null

function ffmpeg_remove_metadata
    echo 'from video *or* audio' >&2
    read -P 'input: ' -l input || return 121
    not test -f "$input" && return 121
    ffmpeg -i "$input" -c copy -map_metadata -1 "_$input"
    mv -f _$input $input
end
funcsave ffmpeg_remove_metadata >/dev/null
